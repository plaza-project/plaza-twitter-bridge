#!/usr/bin/env python3

import json
import logging
import os
import traceback
import urllib.parse

from plaza_bridge import (
    PlazaBridge,  # Import bridge functionality
    BlockArgument,  # Needed for argument definition
    MessageBasedServiceRegistration,
    VariableBlockArgument,
    BlockContext,
)
import tweepy

from plaza_twitter_service import (
    auth,
    TweetListener,
    config,
    storage,
    assets,
    utils,
)

twitter_token = config.get_twitter_token()
twitter_token_secret = config.get_twitter_token_secret()
STORAGE = storage.get_engine()

AUTH = auth.AuthHandler(config, STORAGE)
LISTENER = TweetListener(AUTH, STORAGE)
ENDPOINT = config.get_bridge_endpoint()

callback_url = utils.ws_endpoint_to_callback_url(ENDPOINT)
print("OAuth callback URL:", callback_url)

class Registerer(MessageBasedServiceRegistration):
    def __init__(self, bridge, *args, **kwargs):
        MessageBasedServiceRegistration.__init__(self, *args, **kwargs)
        self.auth_to_connection = {  }
        self.bridge = bridge

    def get_call_to_action_text(self, extra_data):
        if not extra_data:
            # Initial getter, we could also ignore it
            return """
            Log in Twitter to connect to the service:
            """

        auth = tweepy.OAuthHandler(twitter_token, twitter_token_secret, callback_url)

        redirect_url = auth.get_authorization_url()
        self.auth_to_connection[auth.request_token['oauth_token']] = (extra_data.user_id, auth.request_token)

        return """
        Log in Twitter to connect to the service:

        <a href="{url}">Log in</a>
        """.format(
            url=redirect_url
        )

    def register(self, data, extra_data):
        oauth_data = urllib.parse.parse_qs(data['query_string'])

        token = oauth_data['oauth_token'][0]
        verifier = oauth_data['oauth_verifier'][0]

        connection, request_token = self.auth_to_connection[token]

        auth = tweepy.OAuthHandler(twitter_token, twitter_token_secret)
        auth.request_token = request_token
        auth.get_access_token(verifier)

        is_new = STORAGE.register_user(connection, (auth.access_token, auth.access_token_secret))

        logging.info("(new={}) Connection {} is registered with: {}".format(
            is_new, connection, auth.access_token,
        ))

        if is_new:
            user = tweepy.API(auth).me()
            self.bridge.establish_connection(connection, name=user.screen_name)
        return True


bridge = PlazaBridge(
    name="Twitter",
    endpoint=ENDPOINT,
    icon=assets.open_icon(),
    events=['on_new_tweet'],
)

registerer = Registerer(bridge=bridge)
bridge.registerer = registerer

on_new_tweet_event = bridge.events.on_new_tweet
on_new_tweet_event.add_trigger_block(
    id="on_new_tweet_by_account",
    message="When %1 tweets. Save to %2",
    arguments=[BlockArgument(str, "obichero"), VariableBlockArgument(str)],
    subkey=BlockContext.ARGUMENTS[0],
    save_to=BlockContext.ARGUMENTS[1],
)


@on_new_tweet_event.on_new_listeners
def on_new_listeners(user, subkey):
    LISTENER.add_to_user(user, subkey)


def send_message_to_platform(user_id, message):
    logging.info("sending message: {}".format(get_tweet_message(message._json)))
    on_new_tweet_event.send(
        to_user=user_id,
        content=message._json,
        event=message._json,
    )

LISTENER.on_message = send_message_to_platform


@bridge.getter(
    id="get_last_tweet",  # Give it an ID
    message="Get last tweet from %1",  # Set block message
    arguments=[
        BlockArgument(str, "obichero"),
    ],
)
def get_last_tweet(account_name, extra_data):
    timeline = AUTH.get_api(extra_data.user_id).user_timeline(account_name, count=1)
    if len(timeline) == 0:
        raise Exception("Empty timeline")
    return timeline[0]._json


@bridge.getter(
    id="get_tweet_message",  # Give it an ID
    message="Get message from tweet in %1",  # Set block message
    arguments=[
        BlockArgument(str, '<< Add here a "get-tweet" block >>'),
    ]
)
def get_tweet_message(tweet_data, extra_data=None):
    return tweet_data['text']

@bridge.operation(
    id="get_hashtags",  # Give it an ID
    message="Save hashtags from tweet in %1 to %2",  # Set block message
    arguments=[
        BlockArgument(str, '<< Add here a "get-tweet" block >>'),
        VariableBlockArgument(list),
    ],
    save_to=BlockContext.ARGUMENTS[1],
)
def get_tweet_hashtags(tweet_data, extra_data=None):
    hashtags = tweet_data.get('entities', {}).get('hashtags', [])
    return [tag['text'] for tag in hashtags]


if __name__ == "__main__":
    logging.basicConfig(
        format="%(asctime)s - %(levelname)s [%(filename)s] %(message)s")
    logging.getLogger().setLevel(logging.INFO)

    LISTENER.start()
    try:
        bridge.run()
    except Exception:
        traceback.print_exc()
        os._exit(1)

    os._exit(0)  # Force stopping after the bridge ends
